
\section{Simply Typed Lambda Calculus}

\begin{frame}
  \begin{mdframed}[frametitle={Terms, values and types}]
\begin{displaymath}
    \begin{aligned}
t \quad:=\quad& ~ \ldots &\\
  & ~ x \quad\quad &variable\\
  & ~ \lambda~x \highlight{{:} T} . t \quad\quad &abstraction\\
  & ~ t ~ t \quad\quad &function~application\\
v \quad:=\quad& ~ \ldots &\\
  & ~ \lambda~x \highlight{{:} T} . t \quad\quad &abstraction\\
T \quad:=\quad& ~ \ldots &\\
  & ~ \highlight{T \rightarrow T} \quad\quad &function~arrow\\
    \end{aligned}
\end{displaymath}
\end{mdframed}
\medskip
\begin{overprint}
  \onslide<1>
  We need some extra information to make the typing rules work.
  \onslide<2>
  We add {\it type annotations} to the variable bindings in our lambda terms.
  \onslide<3>
  We also add an arrow type, that describes the type of functions.
\end{overprint}
\end{frame}

\begin{frame}
  \begin{mdframed}[frametitle={Small-step semantics}]
  \infrule[E-App1]
  {t_1 \longrightarrow {t_1}^{\prime}}
  {t_1~t_2 \longrightarrow {t_1}^{\prime}~t_2}
  \infrule[E-App2]
  {t_2 \longrightarrow {t_2}^{\prime}}
  {v_1~t_2 \longrightarrow v_1~{t_2}^{\prime}}
  \infrule[E-AppLam]
  {}
  {(\lambda~x \highlight{{:} T} . t_1) t_2 \longrightarrow \left[x \mapsto t_2 \right]t_1}
\end{mdframed}
\medskip
Unsurprisingly, the small-step semantics don't change.
\end{frame}

\begin{frame}
  \begin{mdframed}[frametitle={Typing rules}]
\begin{overprint}
  \onslide<1,4,5,7,8>

  \infrule[T-Var]
  {\highlight[white]{x {:} T} \in \highlight[white]{\Gamma}}
  {\highlight[white]{\Gamma} \vdash x {:} T}

  \infrule[T-App]
  {\highlight[white]{\Gamma} \vdash t_1 {:} T_1 \rightarrow T_2 \andalso \highlight[white]{\Gamma} \vdash t_2 {:} T1}
  {\highlight[white]{\Gamma} \vdash t_1~t_2 {:} T_2}

  \infrule[T-Lam]
  {\highlight[white]{\Gamma , x {:} T_1} \vdash t {:} T_2}
  {\highlight[white]{\Gamma} \vdash \left( \lambda~x {:} T_1 . t \right) {:} T_1 \rightarrow T_2}

  \onslide<2>

  \infrule[T-Var]
  {\highlight[white]{x {:} T} \in \highlight{\Gamma}}
  {\highlight{\Gamma} \vdash x {:} T}

  \infrule[T-App]
  {\highlight{\Gamma} \vdash t_1 {:} T_1 \rightarrow T_2 \andalso \highlight{\Gamma} \vdash t_2 {:} T1}
  {\highlight{\Gamma} \vdash t_1~t_2 {:} T_2}

  \infrule[T-Lam]
  {\highlight{\Gamma , x {:} T_1} \vdash t {:} T_2}
  {\highlight{\Gamma} \vdash \left( \lambda~x {:} T_1 . t \right) {:} T_1 \rightarrow T_2}

  \onslide<3>

  \infrule[T-Var]
  {\highlight{x {:} T} \in \highlight[white]{\Gamma}}
  {\highlight[white]{\Gamma} \vdash x {:} T}

  \infrule[T-App]
  {\highlight[white]{\Gamma} \vdash t_1 {:} T_1 \rightarrow T_2 \andalso \highlight[white]{\Gamma} \vdash t_2 {:} T1}
  {\highlight[white]{\Gamma} \vdash t_1~t_2 {:} T_2}

  \infrule[T-Lam]
  {\highlight[white]{\Gamma , x {:} T_1} \vdash t {:} T_2}
  {\highlight[white]{\Gamma} \vdash \left( \lambda~x {:} T_1 . t \right) {:} T_1 \rightarrow T_2}

  \onslide<6>

  \infrule[T-Var]
  {\highlight[white]{x {:} T} \in \highlight[white]{\Gamma}}
  {\highlight[white]{\Gamma} \vdash x {:} T}

  \infrule[T-App]
  {\highlight[white]{\Gamma} \vdash t_1 {:} T_1 \rightarrow T_2 \andalso \highlight[white]{\Gamma} \vdash t_2 {:} T1}
  {\highlight[white]{\Gamma} \vdash t_1~t_2 {:} T_2}

  \infrule[T-Lam]
  {\highlight{\Gamma , x {:} T_1} \vdash t {:} T_2}
  {\highlight[white]{\Gamma} \vdash \left( \lambda~x {:} T_1 . t \right) {:} T_1 \rightarrow T_2}

\end{overprint}
\end{mdframed}
\medskip
\begin{overprint}
 \onslide<1> 
 Now we need a context for our typing rules.
 \onslide<2> 
 We use $\Gamma$ as the context, which is a map from variables to types.
 \onslide<3> 
 $\text{T-Var}$ just grabs the type from the context.
 \onslide<4> 
 A type error occurs if the variable isn't found in the context.
 \onslide<5> 
 $\text{T-App}$ has no new techniques in it.
 \onslide<6> 
 In $\text{T-Lam}$ we temporarily add $x {:} T_1$ to the context, just for long enough to find the type of $t$.
 \onslide<7> 
 If we didn't modify the context then we would risk a type error occurring if the variable $x$ appeared within the term $t$.
 \onslide<8>
 With that done we know the type of the argument and of the result, so we are done.
\end{overprint}
\end{frame}

\begin{frame}[c]
  \begin{mdframed}[frametitle={Typing rules}]

  \infrule[T-Var]
  { \highlight[white]{x} {:}
    \highlight[white]{T} \in
    \highlight[white]{\Gamma}
  }
  { \highlight[white]{\Gamma} \vdash
    \highlight[white]{x} {:}
    \highlight[white]{T}
  }

  \infrule[T-App]
  { \highlight[white]{\Gamma} \vdash
    \highlight[white]{t_1} {:}
    \highlight[white]{T_1} \rightarrow
    \highlight[white]{T_2} \andalso
    \highlight[white]{\Gamma} \vdash
    \highlight[white]{t_2} {:}
    \highlight[white]{T_1}
  }
  { \highlight[white]{\Gamma} \vdash
    \highlight[white]{t_1} ~
    \highlight[white]{t_2} {:}
    \highlight[white]{T_2}
  }

  \infrule[T-Lam]
  { \highlight[white]{\Gamma} ,
    \highlight[white]{x} {:}
    \highlight[white]{T_1} \vdash
    \highlight[white]{t} {:}
    \highlight[white]{T_2}
  }
  { \highlight[white]{\Gamma} \vdash
    \left(
      \lambda~
      \highlight[white]{x} {:}
      \highlight[white]{T_1} .
      \highlight[white]{t}
    \right) {:}
    \highlight[white]{T_1} \rightarrow
    \highlight[white]{T_2}
  }
  \end{mdframed}

  \begin{displaymath}
    \prftree[r]{T-App}
    {\prftree[r]{T-Lam}
      {\prftree[r]{T-Var}
        {x~{:}~\text{Bool} \in x~{:}~\text{Bool}}
        {x~{:}~\text{Bool} \vdash x~{:}~\text{Bool}}}
      {\vdash \lambda~x~{:}~\text{Bool}~.~x~{:}~\text{Bool} \rightarrow \text{Bool}}}
    {\prftree[r]{T-True}
      {}
      {\vdash \text{true}~{:}~\text{Bool}}}
    {\vdash \left(\lambda~x~{:}~\text{Bool}~.~x\right)~\text{true}~{:}~\text{Bool}}
  \end{displaymath}
\end{frame}
